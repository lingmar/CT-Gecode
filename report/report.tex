\documentclass[a4paper,11pt]{article}
\usepackage{float}
\usepackage{subfig}
\usepackage{fullpage}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
%\pgfplotsset{plot coordinates/math parser=false}
\usetikzlibrary{calc}
\usepackage{cwpuzzle}
\usepackage{astra}
%\usepackage{etoolbox}\AtBeginEnvironment{algorithmic}{\small‌​}
%\usepackage{algorithm2e}
%\usepackage{algorithmicx}
%\input{macros}

%\usepackage{amsthm}
\usepackage{amsthm}

\newtheorem{definition}{Definition}
%\newtheorem{proof}{Proof}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\newcommand{\CT}[0]{CT~}

% Silly but saves space
\newcommand{\T}[1]{\texttt{#1}}

\newcommand{\Timeout}{600.00} % CPU seconds
\newcommand{\Todo}[1]{{\color{blue}#1}}
\newcommand{\Secref}[1]{Section~\ref{#1}}
\newcommand{\Chapref}[1]{Section~\ref{#1}}
\newcommand{\Algoref}[1]{Algorithm~\ref{#1}}
\newcommand{\Table}{\Constraint{Table}~}
\newcommand{\Extensional}{\Constraint{Extensional}~}
\newcommand{\Lineref}[1]{Line~\ref{#1}}
\newcommand{\Linesref}[2]{Lines~\ref{#1}-\ref{#2}}
\newcommand{\lineref}[1]{line~\ref{#1}}
\newcommand{\linesref}[2]{lines~\ref{#1}-\ref{#2}}
\newcommand{\Defref}[1]{Definition~\ref{#1}}
\newcommand{\Thmref}[1]{Theorem~\ref{#1}}
\newcommand{\Lemmaref}[1]{Lemma~\ref{#1}}

\newcommand{\Reg}[0]{Reg~}
\newcommand{\Tups}[0]{Tup\_speed~}
\newcommand{\Tupm}[0]{Tup\_mem~}

\newcommand{\Eqref}[1]{\eqref{#1}}

\newcommand{\Method}[2]{\textbf{method~}\mathrm{{#1}}({#2})}
\newcommand{\MethodReturn}[3]{\textbf{method~}\mathrm{{#1}}({#2})\textbf{\ : \ {#3}}}
\newcommand{\Class}{\textbf{Class~}}
\newcommand{\Constructor}{\textbf{constructor~}}

\newcommand{\Dom}[1]{\text{dom}({#1})}
\newcommand{\Dominit}[1]{\underline{\text{dom}}(#1)}


%\newcommand{\Ceiling}[1]{\left\lceil#1\right\rceil}
%\newcommand{\Floor}[1]{\left\lfloor#1\right\rfloor}


% SparseBitSet
\newcommand{\Words}{\texttt{words}}
\newcommand{\Index}{\texttt{index}}
\newcommand{\Mask}{\texttt{mask}}
\newcommand{\Limit}{\texttt{limit}}
\newcommand{\SparseBitSet}{\texttt{SparseBitSet}}
\newcommand{\Offset}{\texttt{offset}}

% CT Propagator
\newcommand{\Scp}{\texttt{vars}}
\newcommand{\CurrTable}{\texttt{validTuples}}
\newcommand{\Sval}{\texttt{S^{val}}}
\newcommand{\Ssup}{\texttt{S^{sup}}}
\newcommand{\LastSizes}{\texttt{lastSize}}
\newcommand{\Supports}{\texttt{supports}}
\newcommand{\Residues}{\texttt{residues}}

% Pseduo code
\newcommand{\ForEach}[1]{\textbf{foreach } {#1} \textbf{ do }}
\newcommand{\ForEachTo}[3]{\textbf{foreach } {#1} \textbf{ from } {#2} 
  \textbf{ to } {#3} \textbf{ do }}
\newcommand{\ForEachDownTo}[3]{\textbf{foreach } {#1} \textbf{ from } {#2} 
  \textbf{ downto } {#3} \textbf{ do }}
\newcommand{\Break}{\textbf{break~}}
\newcommand{\While}[1]{\textbf{while~} {#1} \textbf{~do~}}

\renewcommand{\algorithmicforall}{\textbf{for all}}
\renewcommand{\algorithmicdo}{}
\renewcommand{\algorithmicwhile}{\textbf{foreach}}

\newcommand{\Func}[2]{\FORALL{#1(#2)}}
\newcommand{\FuncRet}[3]{\FORALL{#1(#2) \ : \ \textbf{#3}}}
\newcommand{\Endfunc}{\ENDFOR}
\newcommand{\To}{~\bf{to}~}
\newcommand{\Downto}{~{\bf{downto}}~}
\newcommand{\For}[3]{\FOR{${#1} \leftarrow {#2} \To {#3}$ \textbf{do}}}
\newcommand{\ForDown}[3]{\FOR{${#1} \leftarrow {#2} \Downto {#3}$ \textbf{do}}}
\newcommand{\FOREACH}[1]{\WHILE{{#1} \textbf{do}}}
\newcommand{\ENDFOREACH}{\ENDWHILE}

\renewcommand{\algorithmiccomment}[1]{\hfill // #1}
\def\PROCEDURE{\item[\textbf{PROCEDURE}]}
\def\FAILED{\textbf{FAILED}}
\def\NOFIX{\textbf{NOFIX}}
\def\FIX{\textbf{FIX}}
\def\SUBSUMED{\textbf{SUBSUMED}}
\def\FAIL{\textbf{FAIL}}
\def\bool{\mathit{bool}}
\def\StatusMessage{\mathit{StatusMessage}}
\def\FindSupport{\textsc{FindSupport}}
\def\RemoveSupport{\textsc{RemoveSupport}}
\def\Extensional{\textsc{Extensional}}
\def\CompactTable{\textsc{CompactTable}}
\def\UpdateTable{\textsc{UpdateTable}}
\def\FilterDomains{\textsc{FilterDomains}}
\def\FixDomains{\textsc{FixDomains}}
\def\InitialiseCT{\textsc{InitialiseCT}}

\newcommand{\ITE}[3]{\text{\bf ~if~} #1 \text{\bf ~then~} #2 \text{\bf ~else~} #3 \text{\bf ~endif}}

\newcommand{\function}[1]{\mathrm{#1}}
\newcommand{\localvar}[1]{\mathit{#1}}

\newlength\myindent
\setlength\myindent{2em}
\newcommand\bindent{%
  \begingroup
  \setlength{\itemindent}{\myindent}
  \addtolength{\algorithmicindent}{\myindent}
}
\newcommand\eindent{\endgroup}

\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
\newcommand{\INDRETURN}[1][1]{\STATE\hspace{#1\algorithmicindent}\textbf{return~}}
\newcommand{\INDIF}[2][1]{\STATE\hspace{#1\algorithmicindent}
  \textbf{if~}{#2}\textbf{~then}}
\newcommand{\INDELSE}[1][1]{\STATE\hspace{#1\algorithmicindent}\textbf{else~}}
\newcommand{\INDELSEIF}[2][1]{\STATE\hspace{#1\algorithmicindent}
  \textbf{else if~}{#2}\textbf{~then}}

\newcommand{\CTpaper}[0]{DBLP:conf/cp/DemeulenaereHLP16}

\numberwithin{equation}{section}

\title{\textbf{Implementation and Evaluation of a\\
    Compact Table Propagator in Gecode
  }
}

\author{Linnea Ingmar} % replace by your name(s)

%\date{Month Day, Year}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}
\label{intro}

In Constraint Programming (CP), every constraint is associated with a propagator
algorithm. The propagator algorithm filters out impossible values for the variables
related to the constraint. For the \Table constraint, several propagator
algorithms are known. In 2016, a new propagator algorithm for the \Table
constraint was published~\cite{\CTpaper}, called Compact Table (CT).
Preliminary results indicate that CT outperforms the previously known algorithms.
There has been no attempt to implement CT in the constraint solver Gecode~\cite{Gecode}, and consequently its performance in Gecode is unknown.

\subsection{Goal}
\label{intro:goal}
The goal of this thesis is to implement a CT propagator
algorithm for the \Table constraint in Gecode,
and to evaluate its performance with respect to the existing propagators.

\subsection{Contributions}
\label{intro:contributions}

\Todo{State the contributions, perhaps as a bulleted list, referring to the different
parts of the paper, as opposed to giving a traditional outline. (As suggested
by Olle Gallmo.)}

This thesis contributes with the following:

\begin{itemize}
  \item The relevant preliminaries have been covered in \Chapref{bg}.
  \item The algorithms presented in~\cite{DBLP:conf/cp/DemeulenaereHLP16} have been modified to suit the
    target constraint solver Gecode, and are presented and explained in 
    \Chapref{algorithms}.
  \item The CT algorithm has been implemented in Gecode, see \Chapref{sec:implementation}.
  \item The performance of the CT algorithm has been evaluated, see \Chapref{evaluation}.
  \item ...
\end{itemize}

\section{Background}
\label{bg}

% Definiera alla begrepp som används senare

This section provides a background that is relevant for the
following sections. It is divided into five parts: \Secref{bg:cp}
introduces Constraint Programming. \Secref{bg:gecode} gives an overview
of Gecode, a constraint solver. \Secref{bg:table} introduces the~\Table
constraint. \Secref{bg:ct} describes the main concepts of the Compact
Table (CT) algorithm. Finally, \Secref{bg:sbs} describes the main
idea of \Todo{Reversible?} Sparse Bit-Sets,
a data structure that is used in the CT algorithm.

\subsection{Constraint Programming}
\label{bg:cp}
This section introduces the concept of Constraint Programming (CP).

CP is a programming paradigm that is used for solving
combinatorial problems. A problem is
modelled as a set of \emph{constraints} and a
set of \emph{variables} with possible values. The possible values of 
a variable is called the \emph{domain} of the variable.
All the variables are to be assigned a value
from their domains, so that all the constraints of the problem
are satisfied. Sometimes the solution should not only satisfy the set of constraints for the
problem, but should also maximise or minimise some given function.

A constraint solver (CP solver) is a software that solves constraint problems.
The solving of a problem consists of generating a search tree by branching
on possible values for the variables. At each node in the search tree,
the solver removes impossible values from the domains of the variables.
This filtering process is called \emph{propagation}. Each constraint is
associated with at least one propagator algorithm, whose task is to detect
values that would violate the constraint if the variables were to be assigned
any of those values, and remove those values from the domain of the variables.

To build intuition and understand the ideas of CP,
the concepts can successfully be demonstrated with logical puzzles. One such
puzzle is Kakuro, a kind of mathematical crossword where the "words" consist
of numbers instead of letters, see Figure~\ref{fig:kakuro}.
The game board consists of 
blank cells forming rows and columns, called \emph{entries}.
Each entry has a \emph{clue}, a prefilled number indicating the sum of that entry.
The size of the board can vary.
The objective is to fill
in digits from 1 to 9 inclusive into each cell such that for each entry,
the sum of all the digits in the entry is equal to the clue of that entry,
and such that each digit appears at most once in each entry.

\begin{figure}
  \centering
  \begin{minipage}{.45\textwidth}
    \begin{Kakuro}{6}{6}
      |  -   |<:9>  |<:26> |  -   |<:19> |<:5>  |  -   |.
      |<16:> |  7   |  9   |<4:9> |  3   |  1   |  -   |.
      |<23:> |  1   |  1   |  1   |  1   |  4   |  -   |.
      |  -   |<6:10>|  1   |  1   |  1   |<:14> |  -   |.
      |<24:> |  1   |  1   |  1   |  1   |  1   |  -   |.
      |<4:>  |  1   |  1   |<15:> |  1   |  1   |  -   |.
    \end{Kakuro}
  \end{minipage}
  \begin{minipage}{.45\textwidth}
    \PuzzleSolution
    %\PuzzleUnitlength=14pt
    %\footnotesize\sf
    \begin{Kakuro}{6}{6}
      |  -   |<:9>  |<:26> |  -   |<:19> |<:5>  |  -   |.
      |<16:> |  7   |  9   |<4:9> |  3   |  1   |  -   |.
      |<23:> |  1   |  1   |  1   |  1   |  4   |  -   |.
      |  -   |<10:6>|  1   |  1   |  1   |<:14> |  -   |.
      |<24:> |  1   |  1   |  1   |  1   |  1   |  -   |.
      |<4:>  |  1   |  1   |<15:> |  1   |  1   |  -   |.
    \end{Kakuro}
  \end{minipage}
  \caption{A Kakuro puzzle~\protect\footnotemark (left) and its solution (right).}
\end{figure}

\footnotetext{From \emph{200 Crazy Clever Kakuro Puzzles - Volume 2}, LeCompte, Dave, 2010.}

A Kakuro puzzle can be modelled as a constraint satisfaction problem with one variable
for each cell, and the domain of each variable being the set $\Set{1,..,9}$.
The constraints of the problem is that the sum of the variables that
belong to a given entry must be equal to the clue for that entry, and the
values of the variables for each entry must be distinct.

An alternative way of phrasing the constraints of Kakuro, is to for each entry
explicitly list all the possible combinations
of values that the variables in that entry can take.
For example, consider an entry of size 2 with clue 4. The only
possible combinations of values are $\Tuple{1,3}$ and $\Tuple{3,1}$, since
these are the only tuples of $2$ distinct digits whose sums are 
equal to~$4$. This way of listing the possible combinations of 
values for the variables is in essence the 
\Table~constraint -- the constraint that is
addressed in this thesis.

\Todo{Really solve the Kakuro in Figure \ref{fig:kakuro}. Kvällspyssel!}

\smallskip 

After gaining some intuition of CP, now follows some formal definitions.
The definitions are based on
\cite{SchulteCarlsson:FDsys}, \cite{Apt:constraintsBook}, and \cite{Gecode:MPG}.

\begin{definition}
  \textbf{Constraint.} Consider a finite sequence of~$n$ 
  variables~$X = x_1,\ldots,x_n$, and a corresponding sequence of
  \emph{domains}~$D = D_1,\ldots,D_n$, that are possible values for the
  respective variable. 
  For a variable~$x_i \in X$, its domain~$D_i$ is denoted 
  by~$dom(x_i)$.
  \begin{itemize}
    \item   A \emph{constraint}~$c$ on~$X$ is a relation, 
      denoted by~$rel(c)$. The associated variables~$X$ are denoted~$vars(c)$,
      and we call~$|vars(c)|$ the \emph{arity} of~$c$. The relation
      $rel(c)$ contains the set of~$n$-tuples that are allowed
      for~$X$, we call those~$n$-tuples \emph{solutions} to the constraint~$c$.
    \item   For an~$n$-tuple~$\tau = \Tuple{a_1,\ldots,a_n}$ associated with~$X$, we
      denote the~$i$th value of~$\tau$ by~$\tau[i]$ or~$\tau[x_i]$. The 
      tuple~$\tau$ is \emph{valid} for~$X$
      if and only if each value of~$\tau$ is in the domain of the corresponding
      variable: $\forall i \in 1 \ldots n, \tau[i] \in dom(x_i)$, or equivalently,
      $\tau \in D_1 \times \ldots \times D_n$.
    \item An~$n$-tuple~$\tau$ is a \emph{support} on a~$n$-ary constraint~$c$ if and only
      if~$\tau$ is valid for~$vars(c)$ and~$\tau$ is a solution to~$c$, that is,
      $\tau$ is contained in~$rel(c)$.
    \item For an~$n$-ary constraint~$c$, involving a variable~$x$ such that
      the value~$a \in dom(x)$, an~$n$-tuple~$\tau$ is a 
      \emph{support for}~$(x,a)$ on~$c$ if and only if~$\tau$ is a support on~$c$,
      and~$\tau[x] = a$.
    \end{itemize}
\end{definition}

\begin{definition}
  \textbf{CSP.} A Constraint Satisfaction Problem (CSP) is a 
  triple~$\left<V,D,C\right>$, where:
  $V = v_1, \ldots, v_n$ is a finite sequence of variables,
  ~$D = D_1, \ldots, D_n$ is a finite sequence of domains for the respective variable,
  and~$C = \Set{c_1, \ldots, c_m}$ is a set of constraints, each on a subsequence of~$V$.
\end{definition}

\begin{definition}
  \textbf{Stores.} A \emph{store}~$s$ is a function, mapping a finite set of
  variables~$V = v_1, \ldots, v_n$ to a finite set of domains. We denote the domain of
  a variable~$v_i$ under~$s$ by~$s(v_i)$ or~$\Dom{v_i}$.
  \begin{itemize}
    \item A store~$s$ is \emph{failed} if and only if~$s(v_i) = \varnothing$ for some~$v_i \in V$.
    \item   A variable~$v_i \in V$ is \emph{fixed}, or \emph{assigned},
      by a store~$s$ if and only if~$|s(v_i)| = 1$. 
    \item A store~$s$ is an \emph{assignment} store if all variables are 
      fixed under~$s$.

    \item Let~$c$ be an $n$-ary constraint on~$V$. A store~$s$ is 
      a \emph{solution store} 
      to~$c$ if and only if~$s$ is an assignment store and the
      corresponding~$n$-tuple is a solution to~$c$:
      $\forall i \in \Set{1,\ldots,n}, s(v_i) = \Set{a_i}$,
      and~$\left<a_1,\ldots,a_n\right>$ is a solution to~$c$.

    \item A store~$s_1$ is \emph{stronger} than a store~$s_2$, 
      written~$s_1 \preceq s_2$ if and only if~$s_1(v) \subseteq s_2(v)$ 
      for all~$v \in V$.
  \end{itemize}

\end{definition}

\subsection{Propagation and propagators}

Constraint propagation is the process of removing values from the domains
of the variables in a CSP that can never appear in a solution store to the 
CSP. In a CP solver, each constraint that the solver implements is associated with 
one or more propagation algorithms, called propagators, whose task is to remove
values that are in conflict with its respective constraint.

To have a well-defined behaviour of propagators, there are some properties that
they must fulfill. Now follows a definition of a propagator and the obligations
that they must meet, taken from \cite{SchulteCarlsson:FDsys} and \cite{Gecode:MPG}.

\begin{definition} \label{def:prop}
  \textbf{Propagators.} A \emph{propagator}~$p$ is a function mapping stores to stores:
  \begin{equation*}
    p: store \mapsto store
  \end{equation*}

  In a CP-solver, a propagator is implemented as a procedure that also returns 
  a \emph{status message}. A propagator must fulfill the following properties:

  \begin{itemize}
  \item A propagator~$p$ is a decreasing function:~$p(s) \preceq s$ for any store~$s$.
    This property guarantees that constraint propagation only removes values.

  \item A propagator~$p$ is a monotonic function:
    ~$s_1 \preceq s_2 \Rightarrow p(s_1) \preceq p(s_2)$
    for any stores~$s_1$ and~$s_2$. This property guarantees that constraint propagation
    preserves the strength-ordering of stores.

  \item A propagator is correct for the constraint it implements.
    A propagator~$p$
    is correct for a constraint~$c$ if and only if it does not
    remove values that are part of supports for~$c$.
    This property guarantees that a propagator does not miss any potential 
    solution store.

  \item A propagator is \emph{checking}: for a given assignment store~$s$, the propagator
    must decide whether~$s$ is a solution store or not for the constraint it
    implements. If~$s$ is a solution store, it must signal subsumption, otherwise
    it must signal failure.

  \item A propagator must be \emph{honest}: it must be 
    \emph{fixpoint honest} and \emph{subsumption honest}. 
    A propagator~$p$ is fixpoint honest if and only if it does not signal 
    fixpoint if it does not return a fixpoint, and it is subsumption honest
    if and only if it does
    not signal subsumption if it is not subsumed by an input store~$s$.
    
    A propagator~$p$ is at \emph{fixpoint} on a store~$s$ if and only if applying 
    $p$ to to~$s$ gives no further propagation:~$p(s) = s$ for
    a store~$s$. If a propagator~$p$ always returns a fixpoint, that is, 
    if~$p(s) = p(p(s))$, $p$ is \emph{idempotent}.

    A propagator is \emph{subsumed} by a store~$s$ if and only if
    all stronger stores are fixpoints:~$\forall s'\preceq s,p(s')=s$.

\end{itemize}

\end{definition}
Note that the honest property of a propagator does not mean that a
propagator is obliged to signal fixpoint or subsumption
if it has computed a fixpoint or is subsumed, only that it must not 
claim that it is at fixpoint or is subsumed if it is not. 
Thus, it is always safe 
(though in many cases not so efficient for the CP-solver)
for a propagator to signal 'not fixpoint', except for a solution store
when it must signal either fail or subsumption.
In fact, a propagator must not even prune values. An extreme case is
the identity propagator~$i$, with~$i(s) = s$ for all input stores~$s$,
which would be correct
for all constraints, as long at is it checking and honest.

To give a measure of how strong the constraint propagation of a propagator
is, it is common to declare a \emph{consistency level} of a propagator.
There are three commonly used consistency levels,
\textbf{value consistency, bounds consistency}, and \textbf{domain consistency}.

\begin{definition}
  \textbf{Domain consistency.} A constraint~$c$ is domain consistent on a store~$s$ 
  if and only if for all variable-value
  pair~$(x,a)$ such that~$x \in vars(c)$ and~$a \in dom(x)$, there exists
  at least one support for~$(x,a)$ on~$c$. 
  A propagator~$p$ is domain consistent, iff~$c$ is domain 
  consistent on $p(s)$ for all stores~$s$ such that~$p(s)$ is not a failed store.
\end{definition}

\Todo{Bounds consistency, Value consistency}.

\subsection{Gecode}
\label{bg:gecode}
Gecode~\cite{Gecode} is a popular constraint programming solver written in C++.

\Todo{Define the parts of the Gecode API that is used later (propagate(), status
  messages...)}

% http://ceur-ws.org/Vol-810/paper-s08.pdf

% definiera de delar av Gecodes API som dyker upp senare, såsom propagate(), status messages
% använda inbyggda klasen BitSets?
%Här bör du bl.a. skriva allt som är relevant för resten av rapporten om Gecodes API. T.ex. de tre returvärdena som propagerare ska returnera, ungefär som du har skrivit i 3.2.3, fast utan det CT-specifika.

\subsection{The \Table Constraint}
\label{bg:table}
The \Table constraint, also called \Extensional,
explicitly expresses the possible combinations of values for the variables as a
sequence of $n$-tuples.

\begin{definition}
  \textbf{Table constraints.} A
  (positive\footnote{There are also negative table constraints, that list the forbidden tuples instead of the allowed tuples.})
  \emph{table constraint c} is a
  constraint such that~$rel(c)$ is defined explicitly by listing all the
  tuples that are solutions to~$c$.
\end{definition}

\subsection{Compact-Table Propagator}
\label{bg:ct}
% Beskriv huvudidéerna
% Komplexitet? Kolla artikeln om negativa table-villkor
% O(r*d*t) per table constraint along a branch in the search tree (artikeln om bakgrund)

\subsection{Sparse Bit-Set}
\label{bg:sbs}
% Beskriv idén

\section{Algorithms}
\label{algorithms}

% Section 3 bör beskriva din design i detalj men samtidigt inte på C++-nivå. Jag gillar att se sjok av pseudokod inbäddade i text som förklarar pseudokoden. Man kan skriva text mellan sjoken och/eller i caption till algorithm-omgivningen. Något som jag också gillar är stepwise refinement, dvs. att först visa en enkel men korrekt version, och sedan en eller flera mer sofistikerade, optimerade versioner. Den pseudokod som du har skrivit passar bra i Section 3, men bryt gärna upp åtminstone Class CT-Propagator i flera stycken algorithm-omgivningar.

This chapter presents the algorithms that are used in the implementation of the
CT propagator in \Chapref{sec:implementation}. In what follows, when we refer to
an array~$a$,~$a[0]$ denotes the first element (indexing starts from~$0$),
$a$.length() the number of its cells and~$a[i:j]$ all its cells in the closed
interval~$[i,j]$, where~$0 \leq i \leq j \leq a.\function{length}() - 1$.
% When we refer to a two-dimensional array~$m$,~$m[i][*]$ denotes
% row~$i$ and~$m[*][j]$ column~$j$, seeing~$m$ as a matrix.

\subsection{Sparse Bit-Set}
\label{sec:sbs}
This section describes Class~$\SparseBitSet$, which is the main data-structure
in the CT algorithm for maintaining the supports.~\Algoref{algo:sparse} shows the
pseudo code for Class~$\SparseBitSet$. The rest of this section describes its
fields and methods in detail.

\begin{algorithm}[H]
  \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
    \input{Class-SparseBitSet.tex}
    \end{algorithmic}
  \caption{Pseudo code for Class SparseBitSet.}
  \label{algo:sparse}
\end{algorithm}

\subsubsection{Fields}
\label{sbs:fields}
% \Todo{It should not be neccassary to keep \Mask~as a field, as it is only used temporarily.
% Unneccessary to copy it every time.}

\Todo{Todo: Add examples.}

\Linesref{line:sbsfield:start}{line:sbsfield:end} of~\Algoref{algo:sparse} shows the fields
of Class~\SparseBitSet~and their types. Now follows a more detailed description of them.

\begin{itemize}
  \item \Words~is an array of~$p$ 64-bit words which defines the current value of the bit-set:
    the~$i$th bit of the~$j$th word is 1 if and only if the $(j-1) \cdot 64 + i$th element of
    the set is present. Initially, all words in this array have all their bits set to~$1$,
    except the last word that may have a suffix of bits set to~$0$. \Todo{Example.}

  \item \Index~is an array that manages the indices of the words in~\Words,
    making it possible to performing operations to non-zero words only.
    In~\Index, the
    indices of all the non-zero words are at positions less than or
    equal to the value of the field~\Limit, and the indices of the zero-words are
    at indices strictly greater than~\Limit. 

  \item \Limit~is the index of~\Index~corresponding to the last non-zero word in~\Words.
    Thus it is one smaller than the number of non-zero words in~\Words.

    % \Limit~is the largest index of~\Index~corresponding to a non-zero word
    % in~\Words.
    % \Todo{Not entirely true, because the indices of the non-zero words will
    %   still be "lying around" at indices $> \Limit$.
    %   But the point is that we only \emph{care} about indices 0..\Limit~in~\Index.
    % Should think of a better formulation.}
  \item \Mask~is a local temporary array that is used to modify the bits in~\Words.
    
    % collect elements with
    % the method addToMask(). It can be cleared with method clearMask(). 
    % A~\SparseBitSet can only be modified by means of the method intersectWithMask().
\end{itemize}

\noindent
The class invariant describing the state of the class is as follows:

\begin{alignat}{1}
  \label{eq:invariant}
  &\Index~\text{is a permutation of~} [0,\dots,p-1],\text{~and} \\
  &\forall i \in \Set{0,\dots,p-1}: i \leq \Limit \Leftrightarrow \Words[\Index[i]] \neq 0^{64}
\end{alignat}

%\begin{alignat}{1}
%   &\Index[0:\Limit]~\text{is a permutation of a subset of~} [0,\dots,p-1],\text{~and} \\
%   &\forall i \in \Set{0,\dots,\Limit}: \Words[\Index[i]] \neq 0^{64}
% \end{alignat}

\subsubsection{Methods}
We now describe the methods in Class~\SparseBitSet~in~\Algoref{algo:sparse}.

\begin{itemize}
  \item initSparseBitSet() in~\linesref{line:initsbs:start}{line:initsbs:end}
    initialises a sparse bit-set-object. It takes 
    the number of bits as an argument and initialises the fields
    described in~\ref{sbs:fields} in a straightforward way.

  \item isEmpty() in lines~\ref{line:isEmpty:1}-\ref{line:isEmpty:2} checks
    if the number of non-zero words is different from zero. If the limit is
    set to~$-1$, that means that all words are zero-words and the bit-set
    is empty.

  \item clearMask() in lines~\ref{line:clearMask:1}-\ref{line:clearMask:4}
    clears the temporary mask. This means setting to~$0$ all words of~$\Mask$
    corresponding to non-zero words of~\Words.

  \item addToMask() in~\linesref{line:addToMask:1}{line:addToMask:4} collects
    elements to the temporary mask by applying a word-by-word logical bit-wise
    \emph{or} operation with a given bit-set (array of long).
    Once again, this operation is only applied to indices corresponding to
    non-zero words in~\Words.

  \item intersectWithMask() in~\linesref{line:intersect:1}{line:intersect:9}
    considers each non-zero word of~\Words~in turn
    and replaces it by its intersection with the corresponding word of~\Mask.
    In case the resulting new word is~$0$, it (its index) is swapped with
    (the index of) the last non-zero word, and~\Limit~is
    decreased by one.
    
    In~\Secref{sec:implementation} we will see that the implementation
    actually can skip~\lineref{line:intersect:8.5} because it is unneccesary
    to save the index of a zero-word in a copy-based solver such as Gecode.
    We keep this
    line here though, because otherwise the invariant in~\Eqref{eq:invariant} 
    would not hold.
    
  \item intersectIndex() in~\linesref{line:interIdx:1}{line:interIdx:7}
    checks whether the intersection of~\Words~and a given bit-set
    (array of long) is empty or not. For all non-zero words in~\Words,
    we perform a logical bit-wise \emph{and} operation 
    in line~\ref{line:interIdx:5} and return
    the index of the word if the intersection is non-empty. If the
    intersection is empty for all words,~$-1$ is returned.
\end{itemize}

\subsection{Compact-Table (CT) Algorithm}
\label{sec:ct}
The CT algortithm is a domain consistent propagation
algorithm for any \Table constraint~$c$. \Secref{ct:pseudo}
presents pseudo code for the CT algorithm and a few variants
and \Secref{sec:proof} proves that CT fulfills the propagator
obligations.

\subsubsection{Pseudo code}
\label{ct:pseudo}
When posting the propagator,
it takes as input a list of variables that are~$vars(c)$,
and an initial table, that is
a list of tuples $T_0 = \Tuple{\tau_0, \tau_1, \ldots, \tau_{p_0-1}}$ of
length~$p_o$. In what follows, we call the \emph{initial valid table}
for~$c$ the subset~$T \subseteq T_0$ of size~$p \leq p_0$ where all
tuples are a support on~$c$ for the initial domains of~$vars(c)$.
For a variable~$x$, we distinguish between the \emph{initial domain}
~$\Dominit{x}$ and the \emph{current domain} $\Dom{x}$.

The propagator state has the following fields.

\begin{itemize}
  \item $\Scp$, a list of variables representing~$vars(c)$.
  
  \item $\CurrTable$, a $\SparseBitSet$ object representing the current valid
    supports for~$c$. If the initial valid table for~$c$
    is $\Tuple{\tau_0, \tau_1, \ldots, \tau_{p-1}}$,
    then~$\CurrTable$ is a 
    $\SparseBitSet$ object of initial size~$p$, such that value~$i$
    is contained (is set to~$1$) if and only if the~$i$th tuple is valid:
    
    \begin{equation} \label{eq:currtable}
      i \in \CurrTable \ \Leftrightarrow \ \forall x \in vars(c): \tau_i[x] \in \Dom{x}
    \end{equation}

  \item $\Supports$, a static array of bit-sets representing
    the supports for each variable-value pair~$(x,a)$.
    %It represents the supports for each variable-value pair~$(x,a)$,
    %where~$x \in vars(c) \land a \in \Dom{x}$.
    %It is a static array of words~$\Supports[x,a]$, seen as bit-sets.
    The bit-set~$\Supports[x,a]$ is such that
    the bit at position~$i$ is set to~$1$ if and only if the 
    tuple~$\tau_i$ in the initial valid table of~$c$ is initially a support for~$(x,a)$:

    \begin{alignat}{1}
      \forall x \in vars(c): \ \forall a \in \Dominit{x}:& \\
      \Supports[x,a][i] = 1 &\quad \Leftrightarrow \\
      (\tau_i[x] = a \quad \land \quad
      \forall y \in vars(c): \ &\tau_i[y] \in \Dominit{y})
    \end{alignat}

    $\Supports$ is computed once during the initialisation of CT and then
    remains unchanged.
    
  \item $\Residues$, an array of ints such that for each variable-value pair~$(x,a)$,
    $\Residues[x,a]$ denotes the index of the word in~$\CurrTable$ where a support
    was found for~$(x,a)$ the last time it was sought for.

\end{itemize}

\Algoref{algo:CT} shows the CT algorithm. Lines 1-4 initialises the propagator
if it is being posted. CT reports failure in case a variable domain was
wiped out in \InitialiseCT or if $\CurrTable$ is empty, meaning no tuples are valid.
If the propagator is not being posted,
lines 6-9 calls \UpdateTable() for all variables whose domains have changed
since last time. \UpdateTable() will remove from $\CurrTable$ the tuples that
are no longer supported, and CT reports failure if all tuples were removed.
If at least one variable was pruned, \FilterDomains() is
called, which will filter out values from the domains of the variables that
no longer have supports, enforcing domain consistency.
CT is subsumed if there is at most one unassigned variable
left, otherwise CT is at fixpoint.

\input{ct-functional.tex}

The initialisation of the fields is described in
\Algoref{algo:initialise-CT}. \InitialiseCT() takes two parameters:
$\localvar{vars}(c)$, that are the variables associated to the constraint~$c$,
and~$\localvar{T_0}$, a list of tuples that define the initial table for~$c$.

\begin{algorithm}[H]
  \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
    \input{initialiseCT.tex}
  \end{algorithmic}
  \caption{Initialising the CT-propagator.}
  \label{algo:initialise-CT}
\end{algorithm}

\Linesref{line:init:-1}{line:init:0} perform simple bounds
  propagation to limit the domain sizes of the variables,
  which in turn will limit the sizes of the data structures.
  It removes
  from the domain of each variable~$x$ all values that are either greater 
  than the largest element or smaller than the smallest element in the
  initial table. If a variable has a domain wipe-out,~$Failed$ is returned.

\Linesref{line:init:3}{line:init:4}~initialise local variables that will be 
used later.

\Linesref{line:init:1}{line:init:5}~initialise the fields~\Scp,
~\Residues~and~\Supports.
The field \Supports~is initialised as an array of bit-sets, with one bit-set for each
variable-value pair, and the size of each
bit-set being the number of tuples in~$\localvar{tuples}$. Each bit-set is assumed
to be initially filled with zeros.

\Linesref{line:init:6}{line:init:7} set the correct bits to~$1$ in~$\Supports$.
For each tuple~$t$, we check if~$t$ is a valid support for~$c$. Recall that~$t$ is
a valid support for~$c$ if and only if~$t[x] \in \Dom{x}$ for all~$x \in scp(c)$.
We keep a counter,~$nsupports$, for the number of valid supports for~$c$.
This is used for indexing the tuples in~$\Supports$ (we only index the tuples
that are valid supports).
If~$t$ is a valid support,
all elements in~$\Supports$ corresponding to~$t$ are set to~$1$ in
line \ref{line:init:10}. We also take the opportunity to store the word index
of the found support in~$\Residues[x,t[x]]$
in line~\ref{line:init:11}.

\Linesref{line:init:12}{line:init:14} remove values that are not supported
by any tuple in the initial valid table. The procedure returns in case a variable
has a domain wipe out.

\Lineref{line:init:15} initialises~$\CurrTable$ as a~$\SparseBitSet$ object with
$nsupports$ bits, initially with all bits set to~$1$ since~$nsupports$
number of tuples are initially valid supports for~$c$.
At this point~$\localvar{nsupports} > 0$,
otherwise we would have returned at line~\ref{line:init:wipeout}.

  \begin{algorithm}[H]
  \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
    \input{updateTable.tex}
  \end{algorithmic}
  \caption{Updating the current table. The infrastructure
  is such that this procedure is called for each variable whose domain is
  modified since last time.}
  \label{algo:updateTable}
\end{algorithm}

  The procedure \UpdateTable() in~\Algoref{algo:updateTable}
  filters out (indices of)
  tuples that have ceased to be supports for the input variable~$x$.
  \Linesref{line:updateTable:5}{line:updateTable:6} stores the union of the
  set of valid tuples for each value~$a \in \Domain{x}$ in the temporary mask
  and \Lineref{line:updateTable:7} intersects~$\CurrTable$ with the mask,
  so that the indices that correspond to tuples that are no longer valid
  are set to~$0$ in the bit-set.
  % \Lineref{line:updateTable:8} checks whether the current table is empty,
  % in which case we return~$Failed$ in line~\ref{line:updateTable:9}
  % because there are no valid tuples left. 

  The algorithm is assumed to be run on an infrastructure that runs updateTable()
  for each variable~$x \in vars(c)$ whose domain has changed since last time.
  
  After the current table has been updated, inconsistent values must be removed
  from the domains of the variables.   
  It follows from the definition of the bit-sets~$\CurrTable$ and~$\Supports[x,a]$
  that~$(x,a)$ has a valid support if and only if 

  \begin{equation}
    \label{eq:validcond}
    (\CurrTable \Inter \Supports[x,a]) \neq \emptyset
  \end{equation}

  Therefore, we must check this condition for every variable-value pair~$(x,a)$ and
  remove~$a$ from the domain of~$x$ if the condition is not satisfied any more.
  This is implemented inx \FilterDomains()
  in~\Algoref{algo:filterDomains}.%lines~\ref{line:filterDom:0}-\ref{line:filterDom:12}.

  \begin{algorithm}[H]
    \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
      \input{filterDomains.tex}
    \end{algorithmic}
    \caption{Filtering variable domains. This procedure is called if 
    at least one variable was modified since last time.}
        \label{algo:filterDomains}
  \end{algorithm}

  % \Lineref{line:filterDom:1} initialises a counter for the number of unassigned
  % variables.
  
  We note that it is only necessary to
  consider a variable~$x \in \Scp$ such that~$\Dom{x} > 1$,
  because we will never filter out values from the domain of an assigned
  variable. To see this, assume we removed the last value for a variable~$x$,
  causing a wipe-out for~$x$. Then by the definition in equation~\eqref{eq:currtable}
  \CurrTable~must be empty,
  which it will not be upon invocation of \FilterDomains, because then
  \CompactTable() would have reported failure. 
  %Hence, we need only consider~$x \in \Scp$ such that~$|\Dom{x} > 1|$.

  In \Linesref{line:filterDom:res1}{line:filterDom:res2} we see if the
  cached word index still has a support for~$(x,a)$. It it has not,
  we search for an index in line~\ref{line:filterDom:4} in~$\CurrTable$
  where a valid support for the variable-value pair~$(x,a)$ is found, 
  thereby checking the condition in~\eqref{eq:validcond}.
  If such an index exists, we cache it in~$\Residues[x,a]$, and
  if it does not, we remove~$a$ from~$\Dom{x}$ if~$(x,a)$ in 
  line~\ref{line:filterDom:7} since there is no support left for~$(x,a)$.

  % \Linesref{line:filterDom:8}{line:filterDom:9}
  % increments the counter of unassigned variables if~$|\Dom{x}| > 1$.

  % \Linesref{line:filterDom:10}{line:filterDom:11} return the correct
  % propagator status message. If the number of unassigned variables is
  % at most one, the propagator is subsumed. Otherwise, the propagator
  % is at fixpoint.


\clearpage

%This description is mainly taken from~\cite{CTpaper}.

% Beskriv övergripande?

% CT is based on bitwise operations -- among the important datastructures we have
% a~$\SparseBitSet$ object which maintains the valid supports, and also a bitset
% matrix that

% In this ordered set, each tuple is indexed
% by the order it appears in the table, and the~$i$th element is~$1$ if and only if
% the~$i$th tuple is a valid support, else the~$i$th element is~$0$.

% \subsubsection{Fields}
% \label{CT:fields}

% \Todo{Add examples with figures for describing the fields.}

% % From hereon, we let the \emph{initial valid table} for $c$,~$T_v$, be a subset of the
% % initial table~$T$ such that for all tuples~$\tau \in T_v$, $\tau$ is a
% % support on~$c$. \Todo{Define: initial table.}
% \Linesref{line:CTfield:start}{line:CTfield:end} of \Algoref{algo:CT}
% shows the fields of Class \texttt{CT-Propagator} and their types.
% Now follows a more detailed description of them. In what follows, we let
% the~\emph{initial domain} of a variable~$x \in \Scp(c)$, denoted~$\Dominit{x}$,
% be the domain that~$x$ has before CT has performed any propagation,
% in contrast to~$\Dom{x}$ which is the current domain of~$x$.
% The \emph{initial table} for a table constraint~$c$ is the list of tuples
% $T_0 = \Tuple{\tau_0, \tau_1, \ldots, \tau_{p_0-1}}$ of length~$p_o$
% that are given as input to initCT(), and the
% \emph{initial valid table} for~$c$ is the subset $T \subseteq T_0$ of size~$p \leq p_0$
% such that~$\forall i \in \Set{1, \ldots, p_0}: \tau_i \in T$ iff $\tau_i$ 
% is a support on~$c$ for the initial domains of the variables. 

% \subsubsection{Methods}

% We now describe the methods of Class \texttt{CT-Propagator}.

% \paragraph{Initialisation.}

% \paragraph{Performing propagation.}
% When the propagator is invoked for propagation, the method propagate()
% in \Algoref{algo:CT} is called. Before defining this function, we need
% to define the help functions updateTable() and filterDomains().
% Performing propagation consists of two steps: updating the current
% table and filtering out inconsistent values from the domains of the variables.
% We now describe these processes in more detail.

% \begin{enumerate}
% \item \textit{Updating the current table.} 
  

% \item 
%   \textit{Filtering of domains.}
  
% \end{enumerate}

% After defining updateTable() and filterDomains(), we are now ready to
% define the method propagate() in Class CT-Propagator, shown 
% in~\Algoref{algo:propagate}.

% \Todo{It should be unneccessary to check if validTuples is empty
%   as that is done in updateTable already. However, when I try to
%   remove the check in the c++ code it crashes, maybe because of
%   synchronisation issues between advise() and propagate().}

% \begin{algorithm}[H]
%   \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
%     \input{propagate.tex}
%   \end{algorithmic}
%   \caption{Method propagate() in Class CT-Propagator. updateTable()
%     (\Algoref{algo:updateTable}) is
%   called, and if the current table is empty, we are in a failed node.
%   Otherwise, filterDomains() (\Algoref{algo:filterDomains})
%   is called, and the return value of that method is returned.}
%   \label{algo:propagate}
% \end{algorithm}

\paragraph{Optimisations.} If~$x$ is the only variable
that has been modified since the last invocation of~\CompactTable(),
it is not necessary to attempt to filter out values from~$x$, because
every value of of~$x$ will have a support in~$\CurrTable$.
Hence, in \Algoref{algo:filterDomains}, we only execute
\Linesref{line:filterDom:3}{line:filterDom:7} for~$\Scp \setminus \Set{x}$.

\paragraph{Variants.}
The following lists some variants of the CT algorithm.
\newline 

\noindent
\emph{Using delta information in \UpdateTable().}
A variable $x$'s delta, $\Delta_x$, is the set of values that were removed from~$x$
since last time. If the infrastructure provides information about $\Delta_x$,
that information can be used in \UpdateTable(). \Algoref{algo:updateTableDelta}
shows a variant of~\UpdateTable() that uses delta information.
If~$\Delta_x$ is smaller than~$\Dom{x}$, we accumulate to the temporary mask
the set of invalidated tuples, and then reverse the temporary mask before
intersecting it with~$\CurrTable$.
\newline

\begin{algorithm}[H]
  \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
    \input{updateTableDelta.tex}
  \end{algorithmic}
  \caption{Updating the current table using delta information.}
  \label{algo:updateTableDelta}
\end{algorithm}

\noindent
\emph{One valid tuple left.} 
If only one valid tuple is left after all calls to \UpdateTable() are finished,
the domains of the variables can be fixed to the values for that tuple.
\Algoref{algo:propagateFix} shows an alternative to lines 10-11 in~\Algoref{algo:CT}.
This assumes that the propagator maintains an extra field~$T$ -- a list
of tuples representing the initial valid table for~$c$.

\begin{algorithm}[H]
  \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
    \input{propagateFix.tex}
  \end{algorithmic}
  \caption{Alternative to lines 10-11 in \Algoref{algo:CT}.}
  \label{algo:propagateFix}
\end{algorithm}

For a word~$\texttt{w}$, there is exactly one bit set if and only if

\begin{equation*}
  \T{w} \neq 0 \quad \land \quad  (\T{w} \ \& \ (\T{w}-1)) \ = \ 0,
\end{equation*}

\noindent
a condition that can be checked in constant time.
This is implemented in~\Algoref{algo:one}, which returns
the bit index of the set bit if there is exactly one bit set, else $-1$.
The method IndexOfFixed() is added to Class \SparseBitSet and assumes access to
builtin~\textsc{MSB}~which returns the most significant bit of a given int.

\begin{algorithm}[H]
  \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
    \input{one.tex}
  \end{algorithmic}
  \caption{Checking if exactly one bit is set in \SparseBitSet.}
  \label{algo:one}
\end{algorithm}

% \Algoref{algo:fixDomains} shows the procedure~\FixDomains() which is called in
% line~\Algoref{algo:proapgateFix} in case there is only one valid tuple left.
% We assume that the propagator status has
% the extra field $T$ -- a list of tuples representing the initial valid
% table for~$c$.

% \begin{algorithm}[H]
%   \begin{algorithmic}[1]  % comment [1] away to drop the line numbers
%     \input{fixDomains.tex}
%   \end{algorithmic}
%   \caption{Fixing the domains of the variables to the only valid tuple.}
%   \label{algo:propagateFix}
% \end{algorithm}

\subsubsection{Proof of properties for CT}
\label{sec:proof}
This section proves that the CT Propagator is indeed a well-defined propagator
implementing the~\Table~constraint. We formulate the following theorem, which
we will prove by a number of lemmas.

\begin{theorem} \label{thm:prop}
  CT is an idempotent, domain consistent propagator implementing 
  the~\Table~constraint, fulfilling the properties in~\Defref{def:prop}.
\end{theorem}

To prove~\Thmref{thm:prop}, we formulate and prove the following lemmas.
In what follows, we denote~$CT(s)$ the resulting store of executing
\CompactTable($s$) on an input store~$s$.

\begin{lemma} \label{lemma:decreasing}
  CT is a decreasing function.
\end{lemma}

\begin{proof}[Proof of \Lemmaref{lemma:decreasing}]
  Since $CT$ only removes values from
  the domains of the variables, we have $CT(s) \preceq s$ for any store $s$.
  Thus, $CT$ is a decreasing function.
\end{proof}

\begin{lemma}\label{lemma:idempotent}
  CT is idempotent.
\end{lemma}

\begin{proof}[Proof of \Lemmaref{lemma:idempotent}]
  To prove that $CT$ is idempotent, we shall show that $CT$ always reaches
  fixpoint for any input store~$s$, that is, $CT(CT(s)) = CT(s)$ for any
  store~$s$.

  Suppose $CT(CT(s)) \neq CT(s)$ for a store~$s$. 
  Since CT is monotonic
  and decreasing, we must have $CT(CT(s)) \prec CT(s)$, that is, $CT$
  must prune at least one value~$a$ from a variable~$x$ from the 
  store~$CT(s)$. 

  By \Eqref{eq:validcond}, there must exists at least one 
  tuple~$\tau_i$
  that is a support for~$(x,a)$ under the store $CT(s)$: 
  $\exists i: i \in \CurrTable \ \land \ \tau_i[x] = a$.
  After \T{updateTable()} is perfomed on~$CT(s)$, we still have
  ~$i \in \CurrTable$, because~$\tau_i$ is still valid in~$CT(s)$.
  Since~\T{filterDomains()} only removes values that have no supports,
  it is impossible that~$a$ is pruned from~$x$, since~$\tau_i$ is a
  support for~$(x,a)$. Hence, we must have~$CT(CT(s)) = CT(s)$.
\end{proof}

% \begin{proof}
%   CT can only remove values from the domains of the variables, it cannot
%   add values to the domains. Therefore, CT is a decreasing function.
% \end{proof}

\begin{lemma}\label{lemma:correct}
  CT is correct for the \Table constraint.
\end{lemma}

\begin{proof}[Proof of \Lemmaref{lemma:correct}]
  $CT$ does not remove values that participate in tuples that are supports
  on a \Table constratint~$c$,
  since \T{filterDomains()} and \T{initCT()} only removes values that 
  have no supports on~$c$. Thus,~$CT$ is correct for \Table.
\end{proof}

\begin{lemma}\label{lemma:checking}
  CT is checking.
\end{lemma}

\begin{proof}[Proof of \Lemmaref{lemma:checking}]
  For an input store~$s$ that is an assignment store, we shall show that $CT$
  signals failure if $s$ is not a solution store, and signals subsumption if
  $s$ is a solution store. 

  First, assume that~$s$ is not a solution store. That means that the tuple
  $\tau = \Tuple{s(x_1),\ldots,s(s_n)}~\notin~c$.
 
  There are two cases, either
  it is the first time $CT$ is applied or it has been applied before.
  If it is the first time, then \T{initCT()} is called.
  Since $\tau$ is not a solution to~$c$, there is at least one variable-value
  pair~$(x_i,s(x_i))$ which is not supported, so~$s(x_i)$ will be pruned
  from~$x$ in \T{initCT()}, which will report failure in line~\Lineref{line:init:wipeoout}
  in~\Algoref{algo:initialise-CT}.
  
  If it is not the first time that $CT$ is called, \T{propagate()} is called.
  Since there are no valid tuples left, \CurrTable~will be empty after
  the call to \T{updateTable()} and $CT$ reports failure.
  
  Now assume that~$s$ is a solution store. 
  $CT$ signals failure in \T{filterDomains()} because all variables are assigned.
  \Todo{Initialisation? Maybe change so that initCT detects subsumption.}
\end{proof}

\begin{lemma}\label{lemma:honest}
  CT is honest.
\end{lemma}

\begin{proof}[Proof of \Lemmaref{lemma:honest}]
  Since $CT$ is idempotent, $CT$ is fixpoint honest. It remains to show that
  $CT$ is subsumption honest.~$CT$ signals subsumption on input store~$s$
  if there is at most one
  unassigned variable~$x$ in~\T{filterDomains()}. After this point, no values will
  ever be pruned from~$x$ by~$CT$, because there will always be a support for
  $(x,a)$ for each value~$a \in dom(x)$. Hence,~$CT$ is indeed subsumed by~$s$
  when it signals subsumption.
    
\end{proof}

\begin{lemma}\label{lemma:domain-consistent}
  CT is domain consistent.
\end{lemma}

\begin{proof}[Proof of \Lemmaref{lemma:domain-consistent}]
  There are two cases; either it is the first time~$CT$ is called, or it
  is not. Both after a call to \T{initCT()} and \T{filterDomains()}, 
  for each variable-value
  pair~$(x,a)$ there exists at least one support, because we filter out those
  values that have no support.
\end{proof}

\begin{lemma}\label{lemma:monotonic}
  CT is a monotonic function.
\end{lemma}

\begin{proof}[Proof of \Lemmaref{lemma:monotonic}]
  Consider two stores~$s_1$ and~$s_2$ such that~$s_1 \preceq s_2$.
  Since~$CT$ is domain consistent, each variable-value pair $(x,a)$
  that is part of~$CT(s_1)$, must also be part of~$CT(s_2)$,
  so~$CT(s_1) \preceq CT(s_2)$.
\end{proof}


After proving Lemmas~\ref{lemma:decreasing}-\ref{lemma:monotonic},
proving~\Thmref{thm:prop} is trivial.

\begin{proof}[Proof of \Thmref{thm:prop}]
  The result follows by Lemmas~\ref{lemma:decreasing}-
  \ref{lemma:monotonic}.
\end{proof}

\section{Implementation}
\label{sec:implementation}

\paragraph{Comparison with implementation in OR-tools}

% Det här är vad jag hittar av värde när jag läser igenom OR-tools kod:

% De har två versioner av CT: en stor (antal tupler > 64) och en liten (antal tupler <= 64). Den lilla versionen drar nytta av att alla aktiva tupler kan representeras med bara ett 64-bitars ord istället för en array av 64-bitars ord. Då kan man till exempel skippa arrayen residues, och arrayen index i SparseBitSet. Osäker på hur stor nytta en sån förändring skulle göra.
% De allokerar arrayer som beror på domän-bredd och inte domän-storlek (för residues och supports), och lagrar initiala minsta domänvärdet för att indexera i dem, precis som jag gör i de fall jag inte använder en hashtabell. Eftersom de inte har en kopieringsbaserad lösare antar jag att det inte är ett problem i deras fall.
% I filterDomains har de några specialfall:
% x.size() == 2: kan titta på bara x.min() och x.max() och fixera x till rätt värde / rapportera fail om inget värde har stöd
% om x’s domän är ett sammanhängande intervall
% Resterande fall.
% I fall 2 och 3 ovan undviker de att använda motsvarande minus_v-operatorn (den som tar bort alla värden i en array) så långt som möjligt eftersom den är dyr, utan använder <=, >=-operatorn på de värden som ska tas bort på x’s gränser och minus_v bara på de värden som ska tas bort mitt i domänen. Jag tror det gäller i Gecode också att minus_v är dyr så det borde jag kunna använda.
% I updateTable har de det här specialfallet som jag kan använda: om variabeln x är fixerad till värdet a behöver jag inte allokera en temporär mask utan kan använda supports[x,a] direkt som mask.

\Todo{Copy-function.}



% Section 4 blir nog mindre intressant än Section 3 och 5, men där kan du skriva om sånt som är specifikt för C++ och Gecode för att algoritmerna i Section 3 ska fungera, precis som du har börjat göra. Det är också en bra plats för detaljer som sopats under mattan i pseudokoden, t.ex. exakt hur du mappar (x,a) till rätt element i supports och residues, med hashtabell eller så.

This section describes an implementation of the CT propagator using the algorithms
presented in \Chapref{algorithms}. The implementation was made in the C++ programming
language in the Gecode library.

The bit-set matrix $\Supports$ is static and could be shared between all solution spaces.

The bit-set $\CurrTable$ changes dynamically during propagation and must therefore be copied for
every new space. Can save memory by only copying the non-zero words.

No need to save the $\T{tuples}$ as a field in the propagator class as all
the necessary information is encoded in $\CurrTable$ and $\Supports$.

\Todo{How is the index mapping done in supports and residues?}

% Can't modify the value of the variable while iterating over it
% when using an iterator for a view, the view cannot be modified (or, in C++ lingua: modifying the variable invalidates the iterator).

% The motivation to iterate over range sequences rather than individual values is efficiency:
% as there are typically less ranges than indvidual values, iteration over ranges can be more efficient.

% Sharing of domain and iterators (argument false in inter_v)

%http://www.gecode.org/doc/4.4.0/reference/classGecode_1_1Iter_1_1Values_1_1BitSet.html

% First perform bounds propagation

% Staging p. 324

% Region (memory allocation)

% Multimap for hashing rows?

\section{Evaluation}
\label{evaluation}
This chapter presents the evaluation of the implementation of the CT propagator
presented in \Chapref{sec:implementation}. In \Secref{evaluation:setup},
the evaluation setup is described. In \Secref{evaluation:results} presents
the results of the evaluation. The results are discussed in \Secref{evaluation:discussion}.

% Benchmarks: performance beroende på antalet variabler. 2-ställiga, 3-ställiga, ..., n-ställiga

\subsection{Evaluation Setup}
\label{evaluation:setup}
The correctness of the CT propagator was validated with the existing unit tests
in Gecode for the table constrataint.

A large number of benchmarks were run, comparing the performance of the CT propagator
with the three other existing propagators in Gecode for the table constraint.
The instances used in the benchmarks were written in MiniZinc~\cite{MiniZinc},
a solver-independent constraint modeling language. The experiments were run
under Gecode 5.0 on a 16-core machine with Linux Ubuntu 14.04.5 (64 bit),
Intel Xeon Core of~2.27~GHz, with~25~GB RAM and 8 MB L3 cache. The machines
were accessed via a shared server.

\Todo{\Tupm, \Tups should have better names}

The following section presents the results of the experiments.

\subsection{Results}
\label{evaluation:results}

\subsubsection{Comparing CT and CT(fix)}

The main purpose of this benchmark is to compare the performance of CT and CT(fix).
Figure~\ref{fig:fix} shows that the performance of CT and CT(fix) are the same.
CT and CT(fix) outperform all other methods. Among the
other methods, the performance is essentially the same.

\begin{figure}[H]
  \label{fig:fix}
  \centering
  %\begin{tikzpicture}[scale=1.0]
    \input{crossword-plot.tex}
  %\end{tikzpicture}
\caption{\textbf{Crosswords.} Number of solved instances as a function of time
  for 5 methods.
  The benchmark consists of 72 instances, using a timeout
  of 1000 seconds. Within the timeout,
  CT and CT(fix) could solve 60 instances, \Tupm, and \Tups could
  solve 59 instances, and \Reg could solve 58 instances.}
\end{figure}



\subsubsection{Benchmarks from \cite{\CTpaper}}

% The set of 1,621 instances that were used for the experiments in~\cite{\CTpaper}
% were also used here. The instances were compiled (using~\cite{xcsp2mzn})
% from XCSP 2.1~\cite{DBLP:joxurnals/corr/abs-0902-2362} format 
% -- an XML based format to represent combinatorial constraint problems -- to
% MiniZinc~\cite{MiniZinc} -- a solver-independent constraint modeling language.
% \Todo{By various reasons, only X instances were used.} The instances were run
% once on a \todo{quantum computer} for every propagator and a timeout of
% 1,000 seconds was used.

This set of benchmarks contains 1,621 CSP instances that where used in the
experiments in~\cite{\CTpaper}, written in XCSP2.1.
This corresponds to a large variety of instances,
taken from 37 series. 117 instances were skipped due to parse problems.
Due to the high number of instances, the runtime for
each instance was only measured once. A timeout of 1000 seconds was used.

%\input{graphs.tex}





% \paragraph{Crosswords}
% Crosswords_lexVg
% Crosswords_wordsPuzzle
% Crosswords_wordsVg

% \paragraph{Travelling Salesman Problem}
% TSP_20
% TSP_25
% TSP_Quat_20


% a10
% a5
% aim-100-pos
% aim-200-pos
% aim-50-pos
% bddLarge
% bddSmall
% dubois
% geom
% k5_n10_d10_m15_p08

% \paragraph{Kakuro}
% kakuroext_easy
% kakuroext_hard
% kakuroext_medium

% \paragraph{Langford}
% langford2
% langford3
% langford4

% \paragraph{MDD}
% mdd05
% mdd07
% mdd09


% modRenault

% \paragraph{Nonograms}
% nonograms

% pigeonsplus

% \paragraph{Randomised instances}
% randsJC10000
% randsJC2500
% randsJC5000
% randsJC7500

% ssa

% \begin{table}[t] \tiny
%   \centering
%   \begin{tabular}{rrrrrrr}  % right alignment --> decimal point alignment
%     $n$ & $runtime_g$ & $fail_g$ & $nprops_g$ & $runtime_c$ & $fail_c$ & $nprops_c$ \\
%     \midrule
%     \input{results-crosswords.tex} % let your experiment script write directly
%                             % into this file, making sure every number
%                             % in a column has the _same_ number of decimals
%   \end{tabular}
%   \caption{}
%   \label{tab:res:sat}
% \end{table}


\subsection{Discussion}
\label{evaluation:discussion}



\section{Conclusions and Future Work}
\label{conclusions}

\bibliographystyle{abbrv}
\bibliography{astra,mybib}

\appendix
\section{Source Code}
\label{sec:source-code}


This appendix presents the source code for the implementation described in \Chapref{sec:implementation}.





\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

% OscaR source code:
% https://bitbucket.org/oscarlib/oscar/src/40e25aafba8f9b0ab06029449350a2a9d1614854/oscar-algo/src/main/scala/oscar/algo/reversible/ReversibleSparseBitSet.scala?at=dev&fileviewer=file-view-default
% https://bitbucket.org/oscarlib/oscar/src/40e25aafba8f9b0ab06029449350a2a9d1614854/oscar-cp/src/main/scala/oscar/cp/constraints/tables/TableCT.scala?at=dev&fileviewer=file-view-default3

% course note in constraint programming
% http://user.it.uu.se/~pierref/courses/COCP/slides/CourseNotes.pdf

% M-x reftex-parse-all
% F1 b
% M-x customize-group reftex

% Hash Functions
% https://en.wikipedia.org/wiki/Pairing_function
% https://www.cs.hmc.edu/~geoff/classes/hmc.cs070.200101/homework10/hashfuncs.html
% http://stackoverflow.com/questions/37918951/what-is-a-minimal-hash-function-for-a-pair-of-ints-that-has-low-chance-of-collis

